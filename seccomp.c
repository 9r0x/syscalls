short syscall[] = {
	3, 3, 3, 1, 2, 2, 2, 3, 3, 6, 3, 2, 1, 4, 4, 0, 3, 4,
	4, 3, 3, 2, 1, 5, 0, 5, 3, 3, 3, 3, 3, 3, 1, 2, 0, 2,
	2, 1, 3, 0, 4, 3, 3, 3, 6, 6, 3, 3, 2, 3, 2, 3, 3, 4,
	5, 5, 5, 0, 0, 3, 1, 4, 2, 1, 3, 3, 4, 1, 2, 4, 5, 3,
	3, 2, 1, 1, 2, 2, 3, 2, 1, 1, 2, 2, 1, 2, 2, 1, 2, 3,
	2, 2, 3, 3, 3, 1, 2, 2, 2, 1, 1, 4, 0, 3, 0, 1, 1, 0,
	0, 2, 0, 0, 0, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 2,
	2, 2, 4, 3, 2, 2, 2, 3, 1, 1, 2, 2, 2, 3, 2, 3, 2, 2,
	3, 1, 1, 1, 2, 2, 2, 1, 0, 0, 3, 2, -1, 5, 2, 1, 2, 1,
	0, 1, 2, 5, -1, 2, 1, 4, 2, 2, 1, 3, -1, 3, 2, -1, -1, 4,
	-1, -1, -1, -1, -1, -1, 0, 3, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2,
	2, 2, 2, 1, 6, 3, 3, 1, 2, 1, 5, 3, 3, 1, -1, 1, -1, -1,
	5, 3, 1, 0, 4, 4, 3, 4, 2, 1, 1, 2, 2, 2, 4, 1, 4, 4,
	3, 2, -1, 6, 3, 5, 4, 1, 5, 5, 2, 3, 4, 5, 5, 4, 5, 3,
	2, 0, 3, 2, 4, 4, 3, 4, 5, 3, 4, 3, 4, 5, 3, 4, 3, 3,
	6, 5, 1, 2, 3, 6, 4, 4, 4, 6, 4, 6, 3, 2, 1, 4, 4, 2,
	4, 4, 2, 1, 3, 2, 1, 5, 5, 4, 5, 5, 2, 5, 4, 5, 3, 2,
	1, 4, 2, 3, 6, 6, 5, 3, 3, 4, 5, 3, 3, 2, 5, 3, 5, 1,
	3, 3, 6, 6, 6, 4, 2, 1, 5, 6, 4, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 2, 6, 4, 3, 5, 2, 5,
	3, 3, 2, 2, 3, 4, 3, 4, 5, 6, 5, 4, 3, 4, 2, 1, 2, 5,
	4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

static void populate_seccomp_data(struct seccomp_data *sd)
{
	struct task_struct *task = current;
	struct pt_regs *regs = task_pt_regs(task);
	unsigned long args[6];
	unsigned short n_arg;
	int i;

	sd->nr = syscall_get_nr(task, regs);
	sd->arch = syscall_get_arch(task);
	syscall_get_arguments(task, regs, args);
	// Do not block if syscall is not in the list
	// Assuming x64 arch
	n_arg = (syscall[sd->nr] == -1) ? 6 : syscall[sd->nr];
	for (i = 0; i < n_arg; i++)
		sd->args[i] = args[i];
	while (i < 6)
		sd->args[i++] = 0;
	sd->instruction_pointer = KSTK_EIP(task);

	if (sd->nr == 63)
		pr_emerg("Syscall 63 detected, %hu args allowed\n", n_arg);
}